# 가상 메모리(Virtual Memory)
## 가상 메모리란?
-> 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법

### Pros
* 이 기법의 주요 장점 중 하나는 사용자 프로그램이 물리 메모리(Physical Memory)보다 커져도 된다는 것
* 물리 메모리로부터 프로그래머 관점의 논리 메모리를 분리해, 메인 메모리를 균일한 크기의 저장 공간으로 구성된 엄청나게 큰 배열로 추상화 시켜줌
* 메모리의 크기에 제약으로부터 자유로워짐
* 파일과 라이브러리의 공유를 쉽게 해주고 공유 메모리 구현을 가능하게 함

### Cons
* 구현이 복잡하고 어려움
* 잘못 사용하게 된다면 성능이 현저히 저하될 가능성이 있음

## 가상메모리 등장 배경
* 물리적으로 작은 메모리를 설치한 컴퓨터에서 이 메모리보다 큰 프로그램을 실행시키고 싶은 필요에 의해 등장
* 램은 가용할수 있는 용량에서 1바이트만 늘어난다고 해도 **메모리 부족** 오류가 발생함
* 가상 메모리는 프로그램의 차지하는 주소공간(address space)의 개념에 대해 조금 다르게 접근함
	* 프로그램을 실행하는데 얼마나 많은 메모리가 많은 메모리가 필요한가? -> X
	* 프로그램을 실행하는데 필요한 최소한의 메모리는 얼마인가? -> O

## 가상 메모리가 하는 일
* 프로그램의 주요한 부분만 메모리에 올려놓고 나머지 부분을 **보조기억장치**에 위치시켜놓고 필요한 부분만 꺼내서 쓰는 방식이다 -> 운영체제가 동작하는 방식과 비슷

### 가상주소공간
* **가상주소(Virtual Address)**는 **논리주소(Logical Address)**라고도 하며 가상주소공간이란 어플리케이션이 사용 가능한 최대 주소 공간을 말한다.
* CPU 아키텍처에 따라 주소지정을 위한 비트수가 달라지기 때문에 가상주소공간은 아키텍처에 따라 달라지게 된다
	* ex) x86(32-bits) 운영체제는 2^32 ≈ 4GB 이므로 4GB이상의 프로그램은 동작할 수 없다.
* 프로그래머들이 프로그램을 만들 때 사용하는 주소공간은 가상주소들이고 실제 **물리적인 메모리주소(Physical Address or Real Address)**는 아니다.

### MMU(Memory Management Unit)
* 가상주소공간의 가상주소는 MMU에 의해서 물리 주소로 변환 된다.(Mapper 역할) -> 이 덕분에 프로그래머는 가상 주소 공간상에서 프로그램을 짜게 되어 프로그램이나 데이터가 주메모리상에 어떻게 존재하는지 알필요가 없게된다.

## 요구 페이징(Demand Paging)
### 요구 페이징이란?
![](README/Screen%20Shot%202021-04-03%20at%2012.27.21%20AM.png)
* 요구 페이징은 필요한 프로그램만 메모리에 적재하는 방법으로 가상 메모리 시스템에서 많이 사용된다. 
* 요구 페이징을 사용하는 가상메모에서는 페이지들이 실행과정에서 실제로 필요해질때 적재된다.

### 페이지 폴트(Page Fault)
* 프로그램이 자신의 주소공간에는 존재하지만 시스템의 RAM에는 현재 없는 데이터나 코드에 접근을 시도하였을 경우 발생하는 현상이다.
* 페이지 폴트가 발생하면 운영체제는 그 데이터를 메모리로 가져와서 마치 페이지 폴트가 전혀 발생하지 않은 것처럼 프로그램이 계속적으로 작동하게 도와준다
	1. 프로세스에 대한 내부테이블을 검사해서 그 메모리 참조가 유효/무효 인지 알아 낸다.(**유효/무효 비트기법**)
	2. 무효한 페이지에 대한 참조라면 프로세스는 중단된다. 메모리에 없으면 디스크로부터 가져와야 한다.
	3. 빈 공간, 자유 프레임(free frame)을 찾는다.
	4. 디스크에 새로이 할당된 프레임으로 해당 페이지를 읽어 들이도록 요청
	5. 디스크 읽기가 끝나면 이 페이지가 메모리에 있다는 것을 알리기 위해 페이지 테이블을 갱신하며 프로세스가 유지되고 있는 내부테이블을 수정한다.
	6. 트랩에 의해 중단되었던 명령을 다시 수행하며 프로세스는 그 페이지가 항상 메모리에 있엇던 것처럼 간주하여 해당 페이지를 접근할 수 있다.

## 페이지 교체 알고리즘
### FIFO(First In First Out)
* 가장 간단한 알고리즘으로 메모리에  올라온지 가장 오래된 페이지를 교체한다.
![](README/Screen%20Shot%202021-04-03%20at%2012.39.42%20AM.png)
-> 활발하게 사용 중인 페이지를 계속해서 교체한다면 **페이지 부재율이 높아지고 실행속도가 떨어질 위험**이 있다.

### 최적(Optimal) 페이지 교체
* 앞으로 가장 오랫동안 사용되지 않을 페이지를 교체하는 알고리즘이다.
![](README/Screen%20Shot%202021-04-03%20at%2012.43.21%20AM.png)
-> 실제 활용에서는 알 방법이 없기때문에 최적 알고리즘은 **구현이 불가능한 알고리즘**이다. 때문에 이 알고리즘은 다른 알고리즘과 비교연구를 목적으로 활용된다.

### LRU(Least Recently Used)
* **가장 오래 사용되지 않은(Least Recently Used)** 페이지를 교체하는 알고리즘이다.
* 최적 알고리즘과 비슷한 방식의 효과를  낼 수 있는 방법을 사용한 것이 LRU 알고리즘이다.
* 언제 사용될지 미리 아는것이 불가능하다면, 과거의 데이터를 바탕으로 페이지가 사용될 시간을 예측하여 교체하는 것은 
가능하다.
![](README/Screen%20Shot%202021-04-03%20at%2012.49.47%20AM.png)
-> LRU 알고리즘은 **많은 운영체제가 채택하는 알고리즘**이며, 좋은 알고리즘이라고 평가받고있다.

### 기타
* 아래 두 알고리즘은 잘 사용되지 않는다. 구현에 상당한 LRU만큼 효과적이지 못하기 때문이다.
	1. LFU(Least Frequently Used)
	2. MFU(Most Frequently Used)

## Reference
* 운영체제(Operating System Concepts) 10th Edition
* https://m.blog.naver.com/PostView.nhn?blogId=kywpcm&logNo=30168638211&proxyReferer=https:%2F%2Fwww.google.com%2F
* https://blog.naver.com/kywpcm/30168739044
* https://blog.naver.com/kywpcm/30168742135
* http://egloos.zum.com/sinuk/v/3950704
* https://seungahyoo.tistory.com/70
* https://blog.naver.com/jevida/140191934297
* https://medium.com/pocs/%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-page-replacement-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-650d58ae266b